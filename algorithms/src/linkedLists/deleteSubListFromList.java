package linkedLists;

import java.util.LinkedList;
import java.util.Scanner;

public class deleteSubListFromList {

    public static void main (String[] args) {

        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        LinkedList<Integer> list = new LinkedList<Integer>();
        for (int i = 0; i < n; i++) {
            list.add(sc.nextInt());
        }

        int m = sc.nextInt(); // големина на подлистата

        if (m == 0) { // Handle empty sublist
            System.out.println(list);
            return;
        }
        
        LinkedList<Integer> sublist = new LinkedList<Integer>();
        for (int i = 0; i < m; i++) {
            sublist.add(sc.nextInt());
        }

        
        int suspect = sublist.getFirst(); // 4

//        System.out.println(list);

        for (int i = 0; i < list.size(); i++) { // i ќе оди до list.size() бидејќи ќе бришеме елементи и ќе се менува големината
            int k = 1; // подготовка за евентуално барање
            if (list.get(i).equals(suspect) && i + m <= list.size()) { // ако ти личиш на осомничениот
                boolean found = true; // можно е да има повеќе подлисти во листата
                for (int j = i + 1; j < i + m; j++) { // посомнувај се и почни да бараш во наведениот ранг (od i+1 до i+m)
                    if (!list.get(j).equals(sublist.get(k))) { // ако не се идентични како подлистата, не се малтретирај, потрагата завршува
                        found = false;
                        break;
                    }
                    k++; // ова се извршува ако потрагата се уште е во тек
                }
                if (found) { // ако форот нема break-нато и ако вистински сме ја нашле поднизата
                    list.subList(i, i + m).clear(); // една јака функција од документација што ја најдов,
                    i--; // го намалуваме i за да не се случи да се препокриваат 4 5 6 4 5 6
                }
            }
        }

        System.out.println(list);

        // Задачава беше со комплексно барање, сепак успеав. Прво го најдов кој мене ќе ми биде suspect,
        // т.е што да ми биде прв знак дека нешто не е во ред. Клучен момент е дека итерираме до list.size(),
        // големината на листата не е фиксна, бришеме елементи !

        // На секоја итерација го подготвуваме k, за ако случајно почнеме да бараме,
        // да ни ги даде останатите осомничени за споредување. Во моментот кога ќе наидеме на елемент од листата
        // кој личи на нашиот suspect, веднаш влегуваме во вгнезден фор кој што почнува од i+1
        // (не мора од i да почнува, веќе сме провериле дека се еднакви).
        // Вгнездениот фор оди до i+m (рангот на подлистата е од i до i+m)

        // Ако во било кој момент,
        // list.get(j) не е еднаков со еден од осомничените, sublist.get(k),
        // прекинуваме со потрагата, found го ставаме дека е false и преминуваме на следната итерација.

        // Ако вгнездениот фор не прекине, found ќе остане true и
        // ќе влеземе во if условот (кој што проверува дали found е true).

        // Откако ќе влеземе во if-от, ќе ја искористиме
        // супер cool функцијата list.subList(i, i + m).clear(), која што ја најдов од документацијата за LinkedList,
        // која ќе избрише елементи од индекс i (вклучувајќи) до индекс i+m (исклучувајќи).
        // (i до i+m е рангот на подлистата)

        // * Важно е дека откако ќе го извршиме овој чин на бришење,
        // мора i да го намалиме за едно,
        // за да сме сигурни дека не пропуштаме ништо *

        // доколку не го намалиме i, ќе се зголеми и
        // наредниот елемент кој што би требало да се провери ќе се испушти

        // краток приказ:

        //       i               <-- до каде сме
        // 0 1 2 3 4 5 6 7 8 9   <-- индекси
        // 1 2 3 4 5 6 4 5 6 1   <-- хипотетички елементи на листа ([4, 5, 6] е подлистата која што треба да се избрише)
        //       0 1 2           <-- нашето k кое што го подготвуваме на секоја итерација

        // Кога ќе се избришат [4, 5, 6],
        // i ќе се зголеми и ќе се премести на елементот 5* (скокајќи ја 4-ката**)
        // затоа го намалуваме i

        // ПОЈАСНУВАЊЕ:
        // (*) на приказот е со индекс 7, (5 има индекс 7 на приказот)
        // (**) на приказот е со индекс 6 (4ката има индекс 6 на приказот)

    }

}
