package linkedLists;

import java.util.LinkedList;
import java.util.Scanner;

public class alternatelyDivideByParity {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        LinkedList<Integer> list = new LinkedList<Integer>();

        int n = sc.nextInt();
        for (int i = 0; i < n; i++) {
            list.add(sc.nextInt());
        }

        int begin = 0; // секогаш кога i е парно (за i = 0, 2, 4, ...)
        int end = list.size() - 1; // секогаш кога i е непарно (за i = 1, 3, 5, ...)

        LinkedList<Integer> evens = new LinkedList<>();
        LinkedList<Integer> odds = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) { // разгледуваме од почеток (и одиме напред)
                if (list.get(begin) % 2 == 0) evens.add(list.get(begin));
                else odds.add(list.get(begin));
                begin++; // 1
            } else { // разгледуваме од крај (и се враќаме назад)
                if (list.get(end) % 2 == 0) evens.add(list.get(end));
                else odds.add(list.get(end));
                end--; // 3
            }
        }

        System.out.print(evens.getFirst());
        for (int i = 1; i < evens.size(); i++) {
            System.out.print(" -> " + evens.get(i));
        }

        System.out.println();

        System.out.print(odds.getFirst());
        for (int i = 1; i < odds.size(); i++) {
            System.out.print(" -> " + odds.get(i));
        }


        // Потребно е од листата да ги анализираме елементите
        // и да ги ставаме во 2 резултантни листи, така што
        // едната листа ќе содржи непарни елементи, а другата парни.
        //
        // Во задачата е дадено дека треба да се разгледуваат елементите по следниот редослед:
        //
        //      0 1 2 3 4 <-- индекси
        //      1 2 3 4 5 <-- хипотетички елементи на листа
        //
        //      1 5 2 4 3 (прво од почеток, па од крај, па од втора позиција, па од претпоследна позиција, и така натаму ...)
        //      0 4 1 3 2 (редослед на индексите)

        // Логиката е едноставна, користам две променливи кои што ми служат како покажувачи.
        // Едната променлива begin започнува од 0, а другата променлива end започнува од list.size() - 1
        // Бидејќи на некој начин се „префрла топката“, (од почеток, од крај, од втор елемент, од претпоследен елемент, ...)
        // јасно е дека ќе го разгледуваме begin индексот секогаш кога i е парно (0, 2, 4, ...)
        // а пак end индексот секогаш кога i е непарно (1, 3, 5, ...)
        // Ова го постигнувам со имплементација на if услови на почеток од секоја итерација за да видам
        // од каде треба да гледам, дали од крај или од почеток.
        //
        // Кога проверувам за елементите кои што се на почеток, само тогаш ја зголемувам вредноста на begin за еден
        // Кога проверувам за елементите кои што се на крајот, само тогаш ја намалувам вредноста на end за еден
        //
        //              * доколку би ја зголемувала/намалувала вредноста на
        //              begin/end на секоја итерација тогаш
        //              одредени елементи би се скокале *

        // Уште еден интересен факт е дека немам некој посебен стоп услов бидејќи,
        // треба да имам онолку итерации колку што имам елементи во низата

        // П.С. Решението на задачава ми дојде доста брзо во споредба со претходните задачи кои што ги решавав.
    }

}
